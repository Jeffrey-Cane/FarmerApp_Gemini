# AgriWeather AI Architecture

## 1. Solution Overview
AgriWeather AI ingests real-time and historical weather information, enriches it with agronomic context, and exposes farmer-friendly advisories generated by Google Gemini. The system is composed of a Python backend responsible for data acquisition, analytics, and AI prompt orchestration, and a React single-page application that surfaces localized insights.

## 2. High-Level Components
- **Frontend (React + TypeScript)**
  - Farmer dashboard with locality selection, weather summaries, and advisory timeline.
  - Data visualizations for rainfall, temperature, and anomaly detection.
  - Guidance feed presenting Gemini-generated recommendations in plain language.
- **Backend API (FastAPI)**
  - REST endpoints consumed by the frontend and open for future integrations.
  - Authentication and request validation.
  - Background jobs for scheduled data ingestion and analytics updates.
- **Weather Data Services**
  - Adapters for real-time APIs (e.g., Open-Meteo, Meteostat) and historical datasets.
  - Caching layer via Redis to minimize external API calls and improve response latency.
- **Analytics & Agronomic Insights Engine**
  - Data cleaning and aggregation pipelines (pandas, xarray).
  - Feature extraction (rainfall trends, heat stress indices, growing degree days, pest risk heuristics).
  - Rule-based pre-checks to flag severe conditions even when Gemini is unavailable.
- **Gemini Insight Service**
  - Prompt templates combining analytics outputs with locality context.
  - Safety filters and guardrails to avoid hallucinated agronomic claims.
  - Response parsing and summarization for frontend consumption.
- **Persistence Layer**
  - PostgreSQL (cloud-managed) storing regions, crop profiles, historical weather snapshots, advisory history, and user preferences.
  - Object storage (e.g., GCS/S3) for larger historical datasets.
- **Observability & Ops**
  - Structured logging (JSON) and metrics (Prometheus).
  - Alerting for failed data ingestions or degraded advisory generation.

## 3. Data Flow
1. **Region Setup**: Farmer selects target region/crop via frontend; metadata stored in PostgreSQL.
2. **Ingestion Cycle**: Scheduler triggers weather adapters to pull updated real-time forecasts and merge with stored historical data.
3. **Analytics Pipeline**: Aggregates data to compute rainfall/temperature trends, anomalies, and agronomic indicators.
4. **Advisory Generation**: Backend crafts prompt to Gemini with analytics summary and localized context; response transformed into actionable insights.
5. **Delivery**: Frontend displays the latest advisories, charts, and alerts; notifications can be pushed via email/SMS in later iterations.

## 4. Deployment Topology
- **Backend**: Containerized FastAPI app deployed on managed service (e.g., Google Cloud Run or AWS ECS Fargate).
- **Frontend**: React build hosted on static site hosting (e.g., Vercel, Netlify, or CloudFront + S3).
- **Database**: Managed PostgreSQL (e.g., Cloud SQL, RDS) accessible via private networking.
- **Cache**: Managed Redis (e.g., Memorystore, ElastiCache).
- **CI/CD**: GitHub Actions for linting, testing, and deployments; infrastructure defined via Terraform for reproducibility.

## 5. Security & Compliance Considerations
- API authentication via JWT with short-lived tokens.
- Secrets stored in platform-secret managers (GCP Secret Manager / AWS Secrets Manager).
- PII minimization; only store data essential for agronomic insights.
- Role-based access for future agronomist/admin dashboard.

## 6. Extensibility Notes
- Add support for additional crops by extending crop profiles table with growth stage thresholds.
- Integrate SMS/WhatsApp notifications through modular notification service.
- Machine learning upgrade path: incorporate yield prediction models using historical crop performance data.

## 7. Open Questions / Decisions Needed
1. Finalize target weather APIs and associated usage costs/quotas.
2. Define minimum viable set of agronomic indicators for launch.
3. Choose deployment cloud provider and managed services (database, cache).
4. Determine localization requirements (languages, units, regulatory constraints).

## 8. Beginner-Friendly MVP Scope
- **Agronomic Indicator Set**
  - Low rainfall warning (< 2 mm daily total) prompting light irrigation guidance.
  - Heavy rain alert (> 5 mm/hr current intensity) advising to delay field work.
  - Heat stress alert (> 32°C daytime high) with canopy cooling reminders.
  - Cool night notice (< 12°C overnight low) reminding to monitor seedlings.
  - Favorable conditions fallback message for normal operations.
- **Localization (Initial)**
  - Language: plain English with short sentences; glossary tooltips planned later.
  - Units: Celsius and millimeters (double-check conversions if expanding to imperial regions).
  - Accessibility: high-contrast color palette and readable typography on React frontend.
- **Local Deployment Guidance**
  - Backend: run `uvicorn agriweather.main:create_app --reload` with Python 3.10+ after `pip install -e .`.
  - Frontend: run `npm install && npm run dev` in `frontend/`; proxy targets local FastAPI at `http://127.0.0.1:8000`.
  - Environment: copy `.env.example` to `.env` and set `GEMINI_API_KEY` when available; otherwise fallback advisories remain active.
